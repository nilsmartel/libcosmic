<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generates one or more structures used for parsing attributes in proc macros."><title>def_attrs in zvariant_utils - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zvariant_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zvariant_utils/index.html">zvariant_<wbr>utils</a><span class="version">1.0.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">def_<wbr>attrs</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#nested-attribute-lists" title="Nested attribute lists">Nested attribute lists</a></li><li><a href="#calling-the-macro-multiple-times" title="Calling the macro multiple times">Calling the macro multiple times</a></li><li><a href="#errors" title="Errors">Errors</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate zvariant_<wbr>utils</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">zvariant_utils</a></span><h1>Macro <span class="macro">def_attrs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/zvariant_utils/macros.rs.html#247-492">source</a> </span></div><pre class="rust item-decl"><span class="macro">macro_rules!</span> def_attrs {
    (@attr_ty str) =&gt; { ... };
    (@attr_ty bool) =&gt; { ... };
    (@attr_ty [str]) =&gt; { ... };
    (@attr_ty none) =&gt; { ... };
    (@attr_ty {
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
            $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
        }
    }) =&gt; { ... };
    (@match_attr_with <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident, <span class="macro-nonterminal">$matched</span>:expr) =&gt; { ... };
    (@match_attr str <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr bool <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr [str] <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr none <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:ident, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@match_attr {
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) <span class="macro-nonterminal">$body</span>:tt
    } <span class="macro-nonterminal">$attr_name</span>:ident, <span class="macro-nonterminal">$meta</span>:expr, <span class="macro-nonterminal">$self</span>:ident) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident str) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident bool) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident [str]) =&gt; { ... };
    (@def_ty <span class="macro-nonterminal">$list_name</span>:ident none) =&gt; { ... };
    (
        @def_ty <span class="macro-nonterminal">$list_name</span>:ident {
            $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
            <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
                $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
            }
        }
    ) =&gt; { ... };
    (
        @def_struct
        <span class="macro-nonterminal">$list_name</span>:ident
        $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
        <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
            $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
        }
    ) =&gt; { ... };
    (
        <span class="kw">crate </span><span class="macro-nonterminal">$list_name</span>:ident;
        $(
            $(<span class="attr">#[<span class="macro-nonterminal">$m</span>:meta]</span>)*
            <span class="macro-nonterminal">$vis</span>:vis <span class="macro-nonterminal">$name</span>:ident(<span class="macro-nonterminal">$what</span>:literal) {
                $(<span class="macro-nonterminal">$attr_name</span>:ident <span class="macro-nonterminal">$kind</span>:tt),+
            }
        );+;
    ) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generates one or more structures used for parsing attributes in proc macros.</p>
<p>Generated structures have one static method called parse that accepts a slice of <a href="https://docs.rs/syn/1.0.109/syn/attr/struct.Attribute.html" title="struct syn::attr::Attribute"><code>Attribute</code></a>s.
The method finds attributes that contain meta lists (look like <code>#[your_custom_ident(...)]</code>) and
fills a newly allocated structure with values of the attributes if any.</p>
<p>The expected input looks as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">def_attrs!</span> {
    <span class="kw">crate </span>zvariant;

    <span class="doccomment">/// A comment.
    </span><span class="kw">pub </span>StructAttributes(<span class="string">"struct"</span>) { foo str, bar str, baz none };
    <span class="attr">#[derive(Hash)]
    </span>FieldAttributes(<span class="string">"field"</span>) { field_attr bool };
}</code></pre></div>
<p>Here we see multiple entries: an entry for an attributes group called <code>StructAttributes</code> and
another one for <code>FieldAttributes</code>. The former has three defined attributes: <code>foo</code>, <code>bar</code> and
<code>baz</code>. The generated structures will look like this in that case:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// A comment.
</span><span class="attr">#[derive(Default, Clone, Debug)]
</span><span class="kw">pub struct </span>StructAttributes {
    foo: <span class="prelude-ty">Option</span>&lt;String&gt;,
    bar: <span class="prelude-ty">Option</span>&lt;String&gt;,
    baz: bool,
}

<span class="attr">#[derive(Hash)]
#[derive(Default, Clone, Debug)]
</span><span class="kw">struct </span>FieldAttributes {
    field_attr: <span class="prelude-ty">Option</span>&lt;bool&gt;,
}</code></pre></div>
<p><code>foo</code> and <code>bar</code> attributes got translated to fields with <code>Option&lt;String&gt;</code> type which contain the
value of the attribute when one is specified. They are marked with <code>str</code> keyword which stands
for string literals. The <code>baz</code> attribute, on the other hand, has <code>bool</code> type because it’s an
attribute without value marked by the <code>none</code> keyword.</p>
<p>Currently the following literals are supported:</p>
<ul>
<li><code>str</code> - string literals;</li>
<li><code>bool</code> - boolean literals;</li>
<li><code>[str]</code> - lists of string literals (<code>#[macro_name(foo("bar", "baz"))]</code>);</li>
<li><code>none</code> - no literal at all, the attribute is specified alone.</li>
</ul>
<p>The strings between braces are embedded into error messages produced when an attribute defined
for one attribute group is used on another group where it is not defined. For example, if the
<code>field_attr</code> attribute was encountered by the generated <code>StructAttributes::parse</code> method, the
error message would say that it “is not allowed on structs”.</p>
<h2 id="nested-attribute-lists"><a class="doc-anchor" href="#nested-attribute-lists">§</a>Nested attribute lists</h2>
<p>It is possible to create nested lists for specific attributes. This is done as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">def_attrs!</span> {
    <span class="kw">crate </span>zvariant;

    <span class="kw">pub </span>OuterAttributes(<span class="string">"outer"</span>) {
        simple_attr bool,
        nested_attr {
            <span class="doccomment">/// An example of nested attributes.
            </span><span class="kw">pub </span>InnerAttributes(<span class="string">"inner"</span>) {
                inner_attr str
            }
        }
    };
}</code></pre></div>
<p>The syntax for inner attributes is the same as for the outer attributes, but you can specify
only one inner attribute per outer attribute.</p>
<h2 id="calling-the-macro-multiple-times"><a class="doc-anchor" href="#calling-the-macro-multiple-times">§</a>Calling the macro multiple times</h2>
<p>The macro generates an array called <code>ALLOWED_ATTRS</code> that contains a list of allowed attributes.
Calling the macro twice in the same scope will cause a name alias and thus will fail to compile.
You need to place each macro invocation into a module in that case.</p>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>The generated parse method checks for some error conditions:</p>
<ol>
<li>Unknown attributes. When multiple attribute groups are defined in the same macro invocation,
one gets a different error message when providing an attribute from a different attribute group.</li>
<li>Duplicate attributes.</li>
<li>Missing attribute value or present attribute value when none is expected.</li>
<li>Invalid literal type for attributes with values.</li>
</ol>
</div></details></section></div></main></body></html>